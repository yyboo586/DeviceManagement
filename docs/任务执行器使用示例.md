# 任务执行器使用示例

## 概述

任务执行器支持多种执行方式，包括HTTP请求、脚本执行、函数调用等。通过统一的接口抽象，可以灵活地扩展新的执行器类型。

## 执行器类型

### 1. HTTP执行器 (ExecutorTypeHTTP)

用于执行HTTP请求任务。

#### 参数格式
```json
{
  "url": "http://example.com/api/endpoint",
  "method": "POST",
  "headers": {
    "Content-Type": "application/json",
    "Authorization": "Bearer token123"
  },
  "body": {
    "key": "value",
    "data": "test"
  },
  "timeout": 30
}
```

#### 使用示例
```go
// 创建HTTP任务
job := &model.CronJob{
    Name: "HTTP数据同步",
    InvokeTarget: "http://api.example.com/sync",
    Params: `{
        "url": "http://api.example.com/sync",
        "method": "POST",
        "headers": {"Content-Type": "application/json"},
        "body": {"action": "sync", "timestamp": "2024-01-01"}
    }`,
    CronExpression: "0 */5 * * * *" // 每5分钟执行一次
}
```

### 2. 脚本执行器 (ExecutorTypeScript)

用于执行脚本任务。

#### 参数格式
```json
{
  "script_path": "/path/to/script.sh",
  "args": ["arg1", "arg2"],
  "env": {
    "ENV_VAR1": "value1",
    "ENV_VAR2": "value2"
  },
  "timeout": 60
}
```

#### 使用示例
```go
// 创建脚本任务
job := &model.CronJob{
    Name: "数据备份脚本",
    InvokeTarget: "script:/backup/backup.sh",
    Params: `{
        "script_path": "/backup/backup.sh",
        "args": ["--type=full", "--compress"],
        "env": {"BACKUP_PATH": "/data/backup"}
    }`,
    CronExpression: "0 2 * * *" // 每天凌晨2点执行
}
```

### 3. 函数执行器 (ExecutorTypeFunc)

用于执行函数任务。

#### 参数格式
```json
{
  "function_name": "processData",
  "args": ["param1", "param2"],
  "kwargs": {
    "option1": "value1",
    "option2": "value2"
  }
}
```

#### 使用示例
```go
// 创建函数任务
job := &model.CronJob{
    Name: "数据处理函数",
    InvokeTarget: "func:processData",
    Params: `{
        "function_name": "processData",
        "args": ["batch_id"],
        "kwargs": {"batch_size": 1000, "timeout": 300}
    }`,
    CronExpression: "0 */10 * * * *" // 每10分钟执行一次
}
```

### 4. 默认执行器 (ExecutorTypeDefault)

当无法确定执行器类型时，使用默认执行器。

## 执行结果格式

所有执行器都返回统一的执行结果格式：

```go
type ExecutionResult struct {
    Success   bool        `json:"success"`   // 是否成功
    Message   string      `json:"message"`   // 执行消息
    Duration  int64       `json:"duration"`  // 执行时长(毫秒)
    StartTime time.Time   `json:"startTime"` // 开始时间
    EndTime   time.Time   `json:"endTime"`   // 结束时间
    Data      interface{} `json:"data"`      // 执行返回的数据
    Error     error       `json:"error"`     // 错误信息
}
```

## 扩展新的执行器类型

### 1. 实现Executor接口

```go
type CustomExecutor struct {
    // 自定义字段
}

func (e *CustomExecutor) Execute(ctx context.Context, params interface{}) *ExecutionResult {
    // 实现具体的执行逻辑
    return &ExecutionResult{
        Success: true,
        Message: "自定义执行器执行成功",
        Data:    "执行结果",
    }
}
```

### 2. 注册到工厂

```go
// 在应用启动时注册
factory := NewExecutorFactory()
factory.RegisterExecutor(ExecutorTypeCustom, NewCustomExecutor())
```

### 3. 更新调度器逻辑

在`scheduler.go`的`executeJob`方法中添加新的执行器类型判断：

```go
if len(jobInfo.InvokeTarget) > 6 && jobInfo.InvokeTarget[:6] == "custom" {
    executorType = ExecutorTypeCustom
}
```

## 最佳实践

1. **参数验证**: 在执行器中添加参数验证逻辑
2. **错误处理**: 统一处理执行过程中的异常
3. **日志记录**: 记录详细的执行日志，便于调试
4. **超时控制**: 为长时间运行的任务设置合理的超时时间
5. **资源清理**: 确保执行完成后正确释放资源

## 配置示例

### HTTP任务配置
```yaml
cron_jobs:
  - name: "数据同步"
    invoke_target: "http://api.example.com/sync"
    cron_expression: "0 */5 * * * *"
    params:
      url: "http://api.example.com/sync"
      method: "POST"
      headers:
        Content-Type: "application/json"
        Authorization: "Bearer ${API_TOKEN}"
      body:
        action: "sync"
        timestamp: "{{.Now}}"
      timeout: 30
```

### 脚本任务配置
```yaml
cron_jobs:
  - name: "系统维护"
    invoke_target: "script:/maintenance/cleanup.sh"
    cron_expression: "0 3 * * *"
    params:
      script_path: "/maintenance/cleanup.sh"
      args: ["--log", "--temp"]
      env:
        LOG_LEVEL: "INFO"
        BACKUP_PATH: "/backup"
      timeout: 300
``` 